package guide15_coroutine

import kotlinx.coroutines.*

/**
 * 零、协程本质
 * 协程并不是线程，它是位于线程之上的一套任务调度框架。开发者把任务交给协程，协程再把任务分配给底层的线程，最终仍然是线程完成任务，协程
 * 只是起了一个调度任务的作用。
 * 使用协程与直接使用线程相比有什么优势呢？最主要的就是代码简单。直接使用线程，要等线程执行完后异步回调才能拿到结果，涉及到合作，还要处
 * 理线程间通信，这些用Java语言处理起来比较复杂。而协程在框架层面帮我们处理了这些事情，让我们可以用同步的方式写出异步的代码。其次就是
 * 协程的吞吐量高。协程中的挂起是非阻塞式挂起，它只挂起任务，不挂起线程。线程一刻不停地在工作，只是执行的任务被切换了。
 * 所以协程的工作模式变成了：任务 -> 协程框架 -> 线程
 *
 * 一、协程五要素
 * 1.协程作用域
 * 2.协程作用域的扩展函数
 * 3.协程上下文
 * 4.协程启动模式
 * 5.lambda表达式
 *
 * 二、协程作用域
 * 协程必须在协程作用域中才能启动，协程作用域中定义了一些父子协程的规则，Kotlin 协程通过协程作用域来管控域中的所有协程。
 * 协程作用域间可并列或包含，组成一个树状结构，这就是 Kotlin 协程中的结构化并发。
 *
 * 作用域类型：
 * 1.顶级作用域：没有父协程的协程所在的作用域
 * 2.协同作用域：协程中启动新协程(即子协程)，此时子协程所在的作用域默认为协同作用域，子协程抛出的未捕获异常都将传递给父协程处理，父协
 * 程同时也会被取消；
 * 3.主从作用域：与协同作用域父子关系一致，区别在于子协程出现未捕获异常时不会向上传递给父协程
 *
 * 父子协程间的规则：
 * 1.父协程如果取消或结束了，那么它下面的所有子协程均被取消或结束
 * 2.父协程需等待子协程执行完毕后才会最终进入完成状态，而不管父协程本身的代码块是否已执行完
 * 3.子协程会继承父协程上下文中的元素，如果自身有相同 Key 的成员，则覆盖对应 Key，覆盖效果仅在自身范围内有效
 *
 * 三、使用 Delay 函数延迟协程执行
 * 1.delay 函数是一个非阻塞式挂起函数，它可以让当前协程延迟到指定的时间执行，且只能在协程的作用域或者其他挂起函数中调用
 *
 * 四、使用 runBlocking 函数创建一个能阻塞当前线程的协程作用域
 * 1.runBlocking 函数可以保证在协程作用域内的所有代码和子协程没有全部执行完之前一直阻塞当前线程
 *
 * 五、使用 launch 函数在当前的协程作用域下创建子协程
 *
 * author: qonyqian
 * created on: 2021/9/20 9:07 下午
 * version：1.0
 * description:
 */

@OptIn(DelicateCoroutinesApi::class)
fun main(vararg args: String) {
    //通过launch启动的协程，不一定会被分配到当前线程执行，有可能被分配到其他子线程中执行。
    // 同理在其他方法中启动的协程也一样。
    GlobalScope.launch {
        println("codes run in coroutine scope")
        //delay 挂起当前协程，但是底层线程仍然正常运行。
        delay(500)
        println("codes run in coroutine scope finished")
    }
    //Thread.sleep(1000)

    //runBlocking 挂起当前线程
    val res = runBlocking {
        println("codes run in runBlocking coroutine scope")
        println("codes run in runBlocking coroutine scope finished")
        5
    }
    println("res = $res")
}